
==================== FINAL INTERFACE ====================
2016-12-11 01:27:42.280010888 UTC

interface IBM1-0.1.0.0-CjjbeV2d7nS55Viqk1p5oC:Lib 8001
  interface hash: c4d05d52db1b18e85740dede9e2d1653
  ABI hash: 5b85d39de95b1acaccbf236912119f9b
  export-list hash: 98832a35a5015dfaa07d2264f8ea1f82
  orphan hash: a5d4b512d9135a43180dbfc8f90da904
  flag hash: b159a15c55fa7c6870cb2eb79bbae5a5
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.combinator
  Lib.extractDict
  Lib.foldPairToMap
  Lib.initProbs
  Lib.step
  Lib.Corpus
  Lib.Counts
  Lib.Dictionary
  Lib.Probs
  Lib.Sentence
  Lib.SentencePair
  Lib.Token
  Lib.Totals
module dependencies:
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.0.0*
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      hashable-1.2.4.0@hashable-1.2.4.0-GnltDttmBjG9qGzcjuPOH4
                      hashmap-1.3.2@hashmap-1.3.2-2C53uAaBH6WFrCDE8iWBbb
                      integer-gmp-1.0.0.1
                      text-1.2.2.1@text-1.2.2.1-FgcR4Xf0VlEHD9HLxzq9WJ
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         hashable-1.2.4.0@hashable-1.2.4.0-GnltDttmBjG9qGzcjuPOH4:Data.Hashable.Generic
         text-1.2.2.1@text-1.2.2.1-FgcR4Xf0VlEHD9HLxzq9WJ:Data.Text
         text-1.2.2.1@text-1.2.2.1-FgcR4Xf0VlEHD9HLxzq9WJ:Data.Text.Lazy
         text-1.2.2.1@text-1.2.2.1-FgcR4Xf0VlEHD9HLxzq9WJ:Data.Text.Show
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Complex base-4.9.0.0:Data.Either
                         base-4.9.0.0:Data.Functor.Const base-4.9.0.0:Data.Functor.Identity
                         base-4.9.0.0:Data.List.NonEmpty base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Semigroup base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:Data.Void
                         base-4.9.0.0:GHC.Exts base-4.9.0.0:GHC.Generics
                         base-4.9.0.0:GHC.IO.Exception base-4.9.0.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         text-1.2.2.1@text-1.2.2.1-FgcR4Xf0VlEHD9HLxzq9WJ:Data.Text
                         text-1.2.2.1@text-1.2.2.1-FgcR4Xf0VlEHD9HLxzq9WJ:Data.Text.Lazy
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:Data.Tuple acb0ed10307ed88df6c81b8589f4de16
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:GHC.Real 08bf4acb5f2508f89d6fbcd57fe232e9
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Set 3ed2324fd1e757464a8ac2b636a64e5a
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base 7491ab24d955eec25fba8e0d89b657f1
import  -/  hashmap-1.3.2@hashmap-1.3.2-2C53uAaBH6WFrCDE8iWBbb:Data.HashMap d56bc1380323a4b865cc9fd8689e5107
a2c7823e92b1747bc79145a2124e6b90
  $s$fEq(,) :: GHC.Classes.Eq (Lib.Token, Lib.Token)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Lib.Token, Lib.Token)
                  (GHC.Classes.$fEq(,)_$c==
                     @ Lib.Token
                     @ Lib.Token
                     Lib.$s$fEq(,)_$dEq
                     Lib.$s$fEq(,)_$dEq)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ Lib.Token
                     @ Lib.Token
                     Lib.$s$fEq(,)_$dEq
                     Lib.$s$fEq(,)_$dEq) -}
56dca51e30f41715478df620692189d4
  $s$fEq(,)_$dEq :: GHC.Classes.Eq Lib.Token
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.$fEq[]_$s$fEq[]1 -}
b03358aa13dec1281cc2f3c3430f2e26
  $s$fHashable(,) ::
    Data.Hashable.Class.Hashable (Lib.Token, Lib.Token)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Lib.Token, Lib.Token)
                  Lib.$s$fHashable(,)_$s$fHashable(,)_$chashWithSalt
                  Lib.$s$fHashable(,)_$s$fHashable(,)_$chash -}
3acb1d68b9f73119ed56c75081bc6825
  $s$fHashable(,)_$s$fHashable(,)_$chash ::
    (Lib.Token, Lib.Token) -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SS),1*U(1*U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Lib.Token, Lib.Token)) ->
                 case ds of wild { (,) a4 a5 ->
                 Data.Hashable.Class.$fHashableNonEmpty_$s$chashWithSalt
                   (Data.Hashable.Class.$fHashable[]_$s$chash a4)
                   a5 }) -}
89531e399a766d3730f7a22012be3464
  $s$fHashable(,)_$s$fHashable(,)_$chashWithSalt ::
    GHC.Types.Int -> (Lib.Token, Lib.Token) -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><S(SS),1*U(1*U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (s :: GHC.Types.Int) (ds :: (Lib.Token, Lib.Token)) ->
                 case ds of wild { (,) a4 a5 ->
                 Data.Hashable.Class.$fHashableNonEmpty_$s$chashWithSalt
                   (Data.Hashable.Class.$fHashableNonEmpty_$s$chashWithSalt s a4)
                   a5 }) -}
ca21db90bd8c7b68dcda04afaa64d563
  $s$fOrd(,) :: GHC.Classes.Ord (Lib.Token, Lib.Token)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Lib.Token, Lib.Token)
                  Lib.$s$fOrd(,)_$s$fOrd(,)_$cp1Ord
                  (GHC.Classes.$fOrd(,)_$ccompare
                     @ Lib.Token
                     @ Lib.Token
                     Lib.$s$fOrd(,)1
                     Lib.$s$fOrd(,)1)
                  (GHC.Classes.$fOrd(,)_$c<
                     @ Lib.Token
                     @ Lib.Token
                     Lib.$s$fOrd(,)1
                     Lib.$s$fOrd(,)1)
                  (GHC.Classes.$fOrd(,)_$c<=
                     @ Lib.Token
                     @ Lib.Token
                     Lib.$s$fOrd(,)1
                     Lib.$s$fOrd(,)1)
                  (GHC.Classes.$fOrd(,)_$c>
                     @ Lib.Token
                     @ Lib.Token
                     Lib.$s$fOrd(,)1
                     Lib.$s$fOrd(,)1)
                  (GHC.Classes.$fOrd(,)_$c>=
                     @ Lib.Token
                     @ Lib.Token
                     Lib.$s$fOrd(,)1
                     Lib.$s$fOrd(,)1)
                  (GHC.Classes.$fOrd(,)_$cmax
                     @ Lib.Token
                     @ Lib.Token
                     Lib.$s$fOrd(,)1
                     Lib.$s$fOrd(,)1)
                  (GHC.Classes.$fOrd(,)_$cmin
                     @ Lib.Token
                     @ Lib.Token
                     Lib.$s$fOrd(,)1
                     Lib.$s$fOrd(,)1) -}
f9235e2a0c8bfbbebf4b8c407e426919
  $s$fOrd(,)1 :: GHC.Classes.Ord [GHC.Types.Char]
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.$fOrd[]_$s$fOrd[]1 -}
929443d2d6848548f4ddea6a4bb26688
  $s$fOrd(,)_$s$fOrd(,)_$cp1Ord ::
    GHC.Classes.Eq (Lib.Token, Lib.Token)
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True) Lib.$s$fEq(,) -}
6eb09f510b2cbccd47f9f54b2a47670f
  $sinsert_$sgo5 ::
    Lib.Token
    -> Data.Set.Base.Set Lib.Token -> Data.Set.Base.Set Lib.Token
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
ac71cb18ade34f320abba84ae422ebed
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lib.$trModule2 Lib.$trModule1) -}
5ac2006064c37e7e1a26b771c3473cc0
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Lib"#) -}
1fcf6d8fb1bebec1a57f30e1471d3926
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "IBM1-0.1.0.0-CjjbeV2d7nS55Viqk1p5oC"#) -}
831aa533341c15c3da199bf4c6f10276
  $wfoldPairToMap ::
    (Data.Foldable.Foldable t1, Data.Foldable.Foldable t) =>
    ((t1 t3, t t2) -> t2 -> t3 -> t4 -> t4)
    -> t4 -> t1 t3 -> t t2 -> t4
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(C1(C1(U))))><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ (t :: * -> *)
                   @ (t1 :: * -> *)
                   @ t2
                   @ t3
                   @ t4
                   (w :: Data.Foldable.Foldable t1)
                   (w1 :: Data.Foldable.Foldable t)
                   (w2 :: (t1 t3, t t2) -> t2 -> t3 -> t4 -> t4)
                   (w3 :: t4)
                   (ww :: t1 t3)
                   (ww1 :: t t2) ->
                 let {
                   wild :: (t1 t3, t t2) = (ww, ww1)
                 } in
                 Data.Foldable.foldr
                   @ t
                   w1
                   @ t2
                   @ t4
                   (\ (x :: t2) (acc :: t4) ->
                    Data.Foldable.foldr
                      @ t1
                      w
                      @ t3
                      @ t4
                      (\ (y :: t3) (ac :: t4) -> w2 wild x y ac)
                      acc
                      ww)
                   w3
                   ww1) -}
0862f133b268ffcbda6bad58b82f85b3
  $wgo ::
    [([Lib.Token], [Lib.Token])]
    -> (# Data.Set.Base.Set Lib.Token, Data.Set.Base.Set Lib.Token #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
dd8068c6864df29f7dfa425962207275
  $wgo1 ::
    [([Lib.Token], [Lib.Token])]
    -> (# Data.Set.Base.Set Lib.Token, Data.Set.Base.Set Lib.Token #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
f118fa931b18825b4889c03f623a6221
  type Corpus = [Lib.SentencePair]
7fb5a02b168c9a8f1b14620baa49c8ec
  type Counts =
    Data.HashMap.Map (Lib.Token, Lib.Token) GHC.Types.Float
23ce260db49638840a7467ed5f4ac377
  type Dictionary = Data.Set.Base.Set Lib.Token
7c00e9386762337d6d0b057a2c379525
  type Probs =
    Data.HashMap.Map (Lib.Token, Lib.Token) GHC.Types.Float
8d3e5eebc2149a605a320c8a2175a563
  type Sentence = [Lib.Token]
3e1611e8898e28d3729e0d21df0778f0
  type SentencePair = (Lib.Sentence, Lib.Sentence)
2bd0a9c0c47a200cb67ee416cadd4624
  type Token = GHC.Base.String
b2db1af61e1d5577313d61f045b2b535
  type Totals = Data.HashMap.Map Lib.Token GHC.Types.Float
b6a5806a0caee5dd73f978d5f6398762
  combinator :: (t -> t1 -> t1) -> t -> t1 -> t1
  {- Arity: 3, HasNoCafRefs,
     Strictness: <C(C(S)),C(C1(U))><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ t @ t1 (f :: t -> t1 -> t1) (x :: t) (y :: t1) ->
                 f x (f x y)) -}
c214ef39351bdc31cd842146ab21728c
  extractDict :: Lib.Corpus -> (Lib.Dictionary, Lib.Dictionary)
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Corpus) ->
                 case Lib.$wgo w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
78a9578ee9baf746545b00b08b81492e
  foldPairToMap ::
    (Data.Foldable.Foldable t1, Data.Foldable.Foldable t) =>
    ((t1 t3, t t2) -> t2 -> t3 -> t4 -> t4)
    -> t4 -> (t1 t3, t t2) -> t4
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(A,A,C(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><S(LLC(C(C(S)))LLLLLLLLLLLLL),1*U(A,A,1*C1(C1(C1(U))),A,A,A,A,A,A,A,A,A,A,A,A,A)><L,C(C1(C1(C1(U))))><L,U><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ (t :: * -> *)
                   @ (t1 :: * -> *)
                   @ t2
                   @ t3
                   @ t4
                   (w :: Data.Foldable.Foldable t1)
                   (w1 :: Data.Foldable.Foldable t)
                   (w2 :: (t1 t3, t t2) -> t2 -> t3 -> t4 -> t4)
                   (w3 :: t4)
                   (w4 :: (t1 t3, t t2)) ->
                 case w4 of ww { (,) ww1 ww2 ->
                 Lib.$wfoldPairToMap
                   @ t
                   @ t1
                   @ t2
                   @ t3
                   @ t4
                   w
                   w1
                   w2
                   w3
                   ww1
                   ww2 }) -}
75871d7977eb9735af27efaae7e5575b
  initProbs :: Lib.Corpus -> Lib.Probs
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (corpus :: Lib.Corpus) ->
                 let {
                   probs :: GHC.Types.Float
                   = case Lib.$wgo1 corpus of ww { (#,#) ww1 ww2 ->
                     case ww2 of wild {
                       Data.Set.Base.Bin dt ds1 ds2 ds3
                       -> case GHC.Prim.divideFloat#
                                 1.0#
                                 (GHC.Prim.int2Float# dt) of wild2 { DEFAULT ->
                          GHC.Types.F# wild2 }
                       Data.Set.Base.Tip
                       -> case GHC.Prim.divideFloat# 1.0# 0.0# of wild2 { DEFAULT ->
                          GHC.Types.F# wild2 } } }
                 } in
                 letrec {
                   go :: [([Lib.Token], [Lib.Token])]
                         -> Data.HashMap.Map (Lib.Token, Lib.Token) GHC.Types.Float
                         -> Data.HashMap.Map (Lib.Token, Lib.Token) GHC.Types.Float
                     {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [([Lib.Token], [Lib.Token])])
                       (eta :: Data.HashMap.Map (Lib.Token, Lib.Token) GHC.Types.Float) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> case y of wild1 { (,) f e ->
                          letrec {
                            go1 :: [Lib.Token]
                                   -> Data.HashMap.Map (Lib.Token, Lib.Token) GHC.Types.Float
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Lib.Token]) ->
                              case ds1 of wild2 {
                                [] -> eta
                                : y1 ys1
                                -> let {
                                     z :: Data.HashMap.Map (Lib.Token, Lib.Token) GHC.Types.Float
                                     = go1 ys1
                                   } in
                                   letrec {
                                     go2 :: [Lib.Token]
                                            -> Data.HashMap.Map
                                                 (Lib.Token, Lib.Token) GHC.Types.Float
                                       {- Arity: 1, Strictness: <S,1*U> -}
                                     = \ (ds2 :: [Lib.Token]) ->
                                       case ds2 of wild3 {
                                         [] -> z
                                         : y2 ys2
                                         -> (Data.HashMap.fromList1
                                               @ (Lib.Token, Lib.Token)
                                               @ GHC.Types.Float
                                               Lib.$s$fHashable(,)
                                               Lib.$s$fOrd(,)
                                               (y1, y2)
                                               probs
                                               (go2 ys2))
                                              `cast`
                                            (Sym (Data.HashMap.N:Map[0]
                                                      <(Lib.Token, Lib.Token)>_N
                                                      <GHC.Types.Float>_R)) }
                                   } in
                                   go2 f }
                          } in
                          go ys (go1 e) } }
                 } in
                 go
                   corpus
                   (Data.IntMap.Base.Nil
                      @ (Data.HashMap.Some (Lib.Token, Lib.Token) GHC.Types.Float))
                     `cast`
                   (Sym (Data.HashMap.N:Map[0]
                             <(Lib.Token, Lib.Token)>_N <GHC.Types.Float>_R))) -}
05adcbb274c432948c567bd6153d7280
  step :: Lib.Corpus -> Lib.Probs -> Lib.Probs
  {- Arity: 2, Strictness: <L,U><S,U> -}
"SPEC/Lib $fEq(,) @ Token @ Token" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                              Lib.Token)
                                                   ($dEq1 :: GHC.Classes.Eq Lib.Token)
  GHC.Classes.$fEq(,) @ [GHC.Types.Char]
                      @ [GHC.Types.Char]
                      $dEq
                      $dEq1
  = Lib.$s$fEq(,)
"SPEC/Lib $fHashable(,) @ Token @ Token" [ALWAYS] forall ($dHashable :: Data.Hashable.Class.Hashable
                                                                          Lib.Token)
                                                         ($dHashable1 :: Data.Hashable.Class.Hashable
                                                                           Lib.Token)
  Data.Hashable.Class.$fHashable(,) @ [GHC.Types.Char]
                                    @ [GHC.Types.Char]
                                    $dHashable
                                    $dHashable1
  = Lib.$s$fHashable(,)
"SPEC/Lib $fHashable(,)_$chash @ Token @ Token" [ALWAYS] forall ($dHashable :: Data.Hashable.Class.Hashable
                                                                                 Lib.Token)
                                                                ($dHashable1 :: Data.Hashable.Class.Hashable
                                                                                  Lib.Token)
  Data.Hashable.Class.$fHashable(,)_$chash @ [GHC.Types.Char]
                                           @ [GHC.Types.Char]
                                           $dHashable
                                           $dHashable1
  = Lib.$s$fHashable(,)_$s$fHashable(,)_$chash
"SPEC/Lib $fHashable(,)_$chashWithSalt @ Token @ Token" [ALWAYS] forall ($dHashable :: Data.Hashable.Class.Hashable
                                                                                         Lib.Token)
                                                                        ($dHashable1 :: Data.Hashable.Class.Hashable
                                                                                          Lib.Token)
  Data.Hashable.Class.$fHashable(,)_$chashWithSalt @ [GHC.Types.Char]
                                                   @ [GHC.Types.Char]
                                                   $dHashable
                                                   $dHashable1
  = Lib.$s$fHashable(,)_$s$fHashable(,)_$chashWithSalt
"SPEC/Lib $fOrd(,) @ Token @ Token" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                Lib.Token)
                                                    ($dOrd1 :: GHC.Classes.Ord Lib.Token)
  GHC.Classes.$fOrd(,) @ [GHC.Types.Char]
                       @ [GHC.Types.Char]
                       $dOrd
                       $dOrd1
  = Lib.$s$fOrd(,)
"SPEC/Lib $fOrd(,)_$cp1Ord @ Token @ Token" [ALWAYS] forall ($dOrd :: GHC.Classes.Ord
                                                                        Lib.Token)
                                                            ($dOrd1 :: GHC.Classes.Ord Lib.Token)
  GHC.Classes.$fOrd(,)_$cp1Ord @ [GHC.Types.Char]
                               @ [GHC.Types.Char]
                               $dOrd
                               $dOrd1
  = Lib.$s$fOrd(,)_$s$fOrd(,)_$cp1Ord
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

