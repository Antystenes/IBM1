
==================== FINAL INTERFACE ====================
2016-12-14 12:43:15.085930152 UTC

interface IBM1-0.1.0.0-2Cy7pYQHi2RT2Zw6i7w81:Lib 8001
  interface hash: c9dd7908dc3b3710590c10f59e833e17
  ABI hash: 7e64eafaabafc112f9c062256cc5309c
  export-list hash: 085465c66dd3a1dd0d52159e67012c29
  orphan hash: 2a6c3ecd060ed7e3e533b91573757181
  flag hash: b159a15c55fa7c6870cb2eb79bbae5a5
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lib.extractDict
  Lib.foldPair
  Lib.initProbs
  Lib.iterations
  Lib.loop
  Lib.perplexity
  Lib.readCorpus
  Lib.showProbs
  Lib.step
  Lib.testCorpus
  Lib.Corpus
  Lib.Counts
  Lib.Dictionary
  Lib.Probs
  Lib.Sentence
  Lib.SentencePair
  Lib.Token
  Lib.Totals
module dependencies:
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.0.0*
                      binary-0.8.3.0@binary-0.8.3.0
                      bytestring-0.10.8.1@bytestring-0.10.8.1
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      hashable-1.2.4.0@hashable-1.2.4.0-GnltDttmBjG9qGzcjuPOH4
                      integer-gmp-1.0.0.1
                      text-1.2.2.1@text-1.2.2.1-FgcR4Xf0VlEHD9HLxzq9WJ
                      unordered-containers-0.2.7.1@unordered-containers-0.2.7.1-6Q3w38ZivLTB9nLFgf8RUI*
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         binary-0.8.3.0@binary-0.8.3.0:Data.Binary.Generic
         bytestring-0.10.8.1@bytestring-0.10.8.1:Data.ByteString.Builder
         hashable-1.2.4.0@hashable-1.2.4.0-GnltDttmBjG9qGzcjuPOH4:Data.Hashable.Generic
         text-1.2.2.1@text-1.2.2.1-FgcR4Xf0VlEHD9HLxzq9WJ:Data.Text
         text-1.2.2.1@text-1.2.2.1-FgcR4Xf0VlEHD9HLxzq9WJ:Data.Text.Lazy
         text-1.2.2.1@text-1.2.2.1-FgcR4Xf0VlEHD9HLxzq9WJ:Data.Text.Show
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Complex base-4.9.0.0:Data.Either
                         base-4.9.0.0:Data.Functor.Const base-4.9.0.0:Data.Functor.Identity
                         base-4.9.0.0:Data.List.NonEmpty base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Semigroup base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:Data.Version base-4.9.0.0:Data.Void
                         base-4.9.0.0:GHC.Exts base-4.9.0.0:GHC.Generics
                         base-4.9.0.0:GHC.IO.Exception base-4.9.0.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntMap.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.IntSet.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Sequence
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
                         text-1.2.2.1@text-1.2.2.1-FgcR4Xf0VlEHD9HLxzq9WJ:Data.Text
                         text-1.2.2.1@text-1.2.2.1-FgcR4Xf0VlEHD9HLxzq9WJ:Data.Text.Lazy
                         unordered-containers-0.2.7.1@unordered-containers-0.2.7.1-6Q3w38ZivLTB9nLFgf8RUI:Data.HashMap.Base
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:Data.OldList 0058409f994fb13ae0616e3f1e5b4dae
import  -/  base-4.9.0.0:Data.Tuple acb0ed10307ed88df6c81b8589f4de16
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Float 469226b1bc53433e95d0167dec5d0312
import  -/  base-4.9.0.0:GHC.List 13d2451194c1c6e53b4f4f07947736dd
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:GHC.Real 08bf4acb5f2508f89d6fbcd57fe232e9
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  base-4.9.0.0:System.IO eb1d40aa793a4047069a5023f2ebcfe3
import  -/  base-4.9.0.0:Text.Printf 981db3fab2db52a63576c71c790058bf
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Set 3ed2324fd1e757464a8ac2b636a64e5a
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base 7491ab24d955eec25fba8e0d89b657f1
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 7378e41b7749213c8c88ceb6b0665d4c
import  -/  unordered-containers-0.2.7.1@unordered-containers-0.2.7.1-6Q3w38ZivLTB9nLFgf8RUI:Data.HashMap.Base c39f01cdb67dec42ceac1e4d55503478
import  -/  unordered-containers-0.2.7.1@unordered-containers-0.2.7.1-6Q3w38ZivLTB9nLFgf8RUI:Data.HashMap.Strict a25ea0b8ecb9e8aeb22f3b30030a072f
cf4f6a0c7a6962b0f3a3731452ccf286
  $s!1 :: v
  {- Strictness: x -}
b7e5a71ee684a6339b64e9249a86a348
  $s!_$s$fEq(,) :: GHC.Classes.Eq (Lib.Token, Lib.Token)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Lib.Token, Lib.Token)
                  (GHC.Classes.$fEq(,)_$c==
                     @ Lib.Token
                     @ Lib.Token
                     GHC.Classes.$fEq[]_$s$fEq[]1
                     GHC.Classes.$fEq[]_$s$fEq[]1)
                  (GHC.Classes.$fEq(,)_$c/=
                     @ Lib.Token
                     @ Lib.Token
                     GHC.Classes.$fEq[]_$s$fEq[]1
                     GHC.Classes.$fEq[]_$s$fEq[]1) -}
aa2c27e79e64980b609c33f672b736ed
  $s!_$s$fHashable(,) ::
    Data.Hashable.Class.Hashable (Lib.Token, Lib.Token)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Lib.Token, Lib.Token)
                  Lib.$s!_$s$fHashable(,)_$chashWithSalt
                  Lib.$s!_$s$fHashable(,)_$chash -}
edd0702c6fc35684eed5f67aca01b8dc
  $s!_$s$fHashable(,)_$chash ::
    (Lib.Token, Lib.Token) -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SS),1*U(1*U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Lib.Token, Lib.Token)) ->
                 case ds of wild { (,) a4 a5 ->
                 Data.Hashable.Class.$fHashableNonEmpty_$s$chashWithSalt
                   (Data.Hashable.Class.$fHashable[]_$s$chash a4)
                   a5 }) -}
b2ce85b89b95145821ab9288353581a3
  $s!_$s$fHashable(,)_$chashWithSalt ::
    GHC.Types.Int -> (Lib.Token, Lib.Token) -> GHC.Types.Int
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(U)><S(SS),1*U(1*U,1*U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (s :: GHC.Types.Int) (ds :: (Lib.Token, Lib.Token)) ->
                 case ds of wild { (,) a4 a5 ->
                 Data.Hashable.Class.$fHashableNonEmpty_$s$chashWithSalt
                   (Data.Hashable.Class.$fHashableNonEmpty_$s$chashWithSalt s a4)
                   a5 }) -}
9951f1b49e81e7a8c3d531a62f095446
  $s!_$slookup ::
    [GHC.Types.Char]
    -> Data.HashMap.Base.HashMap [GHC.Types.Char] v -> GHC.Base.Maybe v
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,1*U>,
     Unfolding: (\ @ v
                   (k0 :: [GHC.Types.Char])
                   (m0 :: Data.HashMap.Base.HashMap [GHC.Types.Char] v) ->
                 case Data.Hashable.Class.$wgo
                        k0
                        -2578643520546668380#
                        0# of ww2 { (#,#) ww3 ww4 ->
                 Lib.$wpoly_go1
                   @ v
                   (GHC.Prim.int2Word#
                      (GHC.Prim.xorI# (GHC.Prim.*# ww3 16777619#) ww4))
                   k0
                   0#
                   m0 }) -}
df32de832970220e2389a3221f920e0c
  $s$wupdateOrSnocWithKey ::
    ([GHC.Types.Char] -> v -> v -> v)
    -> [GHC.Types.Char]
    -> v
    -> GHC.Prim.Array# (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
    -> GHC.Prim.Array# (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
  {- Arity: 4, Strictness: <L,C(C1(C1(U)))><S,1*U><L,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ v
                   (w1 :: [GHC.Types.Char] -> v -> v -> v)
                   (w2 :: [GHC.Types.Char])
                   (w3 :: v)
                   (ww :: GHC.Prim.Array#
                            (Data.HashMap.Base.Leaf [GHC.Types.Char] v)) ->
                 letrec {
                   $wgo6 :: [GHC.Types.Char]
                            -> v
                            -> GHC.Prim.Array# (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                            -> GHC.Prim.Int#
                            -> GHC.Prim.Int#
                            -> GHC.Prim.Array# (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                     {- Arity: 5, Strictness: <S,1*U><L,U><S,U><S,U><S,U>,
                        Inline: [0] -}
                   = \ (w :: [GHC.Types.Char])
                       (w4 :: v)
                       (ww1 :: GHC.Prim.Array#
                                 (Data.HashMap.Base.Leaf [GHC.Types.Char] v))
                       (ww2 :: GHC.Prim.Int#)
                       (ww3 :: GHC.Prim.Int#) ->
                     case w of k2 { DEFAULT ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.>=# ww2 ww3) of wild {
                       GHC.Types.False
                       -> case GHC.Prim.indexArray#
                                 @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                 ww1
                                 ww2 of ds { Unit# ipv3 ->
                          case ipv3 of wild1 { Data.HashMap.Base.L kx y ->
                          case GHC.Base.eqString k2 kx of wild2 {
                            GHC.Types.False -> $wgo6 k2 w4 ww1 (GHC.Prim.+# ww2 1#) ww3
                            GHC.Types.True
                            -> case w1 k2 w4 y of v' { DEFAULT ->
                               case GHC.Prim.thawArray#
                                      @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                      @ GHC.Prim.RealWorld
                                      ww1
                                      0#
                                      (GHC.Prim.sizeofArray#
                                         @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                         ww1)
                                      GHC.Prim.realWorld# of ds1 { (#,#) ipv4 ipv5 ->
                               case GHC.Prim.writeArray#
                                      @ GHC.Prim.RealWorld
                                      @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                      ipv5
                                      ww2
                                      (Data.HashMap.Base.L @ [GHC.Types.Char] @ v k2 v')
                                      ipv4 of s' { DEFAULT ->
                               case GHC.Prim.unsafeFreezeArray#
                                      @ GHC.Prim.RealWorld
                                      @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                      ipv5
                                      s' of ds2 { (#,#) ipv6 ipv7 ->
                               ipv7 } } } } } } }
                       GHC.Types.True
                       -> case GHC.Prim.newArray#
                                 @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                 @ GHC.Prim.RealWorld
                                 (GHC.Prim.+# ww3 1#)
                                 (Data.HashMap.Array.undefinedElem
                                    @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v))
                                 GHC.Prim.realWorld# of ds { (#,#) ipv3 ipv4 ->
                          case w4 of v2 { DEFAULT ->
                          case GHC.Prim.copyArray#
                                 @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                 @ GHC.Prim.RealWorld
                                 ww1
                                 0#
                                 ipv4
                                 0#
                                 ww3
                                 ipv3 of s2 { DEFAULT ->
                          case GHC.Prim.writeArray#
                                 @ GHC.Prim.RealWorld
                                 @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                 ipv4
                                 ww3
                                 (Data.HashMap.Base.L @ [GHC.Types.Char] @ v k2 v2)
                                 s2 of s' { DEFAULT ->
                          case GHC.Prim.unsafeFreezeArray#
                                 @ GHC.Prim.RealWorld
                                 @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                 ipv4
                                 s' of ds1 { (#,#) ipv5 ipv6 ->
                          ipv6 } } } } } } }
                 } in
                 $wgo6
                   w2
                   w3
                   ww
                   0#
                   (GHC.Prim.sizeofArray#
                      @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                      ww)) -}
bb048dea8b7672d365ac1d8482d6f17d
  $sinsertWith ::
    (v -> v -> v)
    -> [GHC.Types.Char]
    -> v
    -> Data.HashMap.Base.HashMap [GHC.Types.Char] v
    -> Data.HashMap.Base.HashMap [GHC.Types.Char] v
  {- Arity: 4, Strictness: <L,C(C1(U))><S,U><L,U><S,1*U> -}
46b7e347a2eac4f7cd965a84f35946a3
  $sinsert_$sgo5 ::
    Lib.Token
    -> Data.Set.Base.Set Lib.Token -> Data.Set.Base.Set Lib.Token
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
7f634b959ae54478c0ada5f60c0c522d
  $sprintf3 ::
    GHC.Base.String -> [Text.Printf.UPrintf] -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ (fmts :: GHC.Base.String)
                   (args :: [Text.Printf.UPrintf]) ->
                 GHC.Base.map
                   @ GHC.Types.Char
                   @ GHC.Types.Char
                   Text.Printf.$fIsCharChar_$cfromChar
                   (Text.Printf.uprintfs
                      fmts
                      (GHC.List.reverse1
                         @ Text.Printf.UPrintf
                         args
                         (GHC.Types.[] @ Text.Printf.UPrintf))
                      (GHC.Types.[] @ GHC.Types.Char))) -}
c966bc15011a3563eea45681fd8d3aa3
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lib.$trModule2 Lib.$trModule1) -}
77b4e4253f0e0da043ae164a88db6c07
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Lib"#) -}
a9092536f7d6e5f2cd69d94e05f162cb
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "IBM1-0.1.0.0-2Cy7pYQHi2RT2Zw6i7w81"#) -}
572a7addd1e2e83f37dbae4a18e729a3
  $w$sinsertWith ::
    (v -> v -> v)
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> v
    -> Data.HashMap.Base.HashMap ([GHC.Types.Char], [GHC.Types.Char]) v
    -> Data.HashMap.Base.HashMap ([GHC.Types.Char], [GHC.Types.Char]) v
  {- Arity: 5, Strictness: <L,C(C1(U))><S,U><S,U><L,U><S,1*U>,
     Inline: [0] -}
cb3aba68e6fbb2c601ab5daee7712fdf
  $wfoldPair ::
    (Lib.SentencePair -> Lib.Token -> Lib.Token -> a -> a)
    -> a -> Lib.Sentence -> Lib.Sentence -> a
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,C(C1(C1(C1(U))))><L,U><L,U><S,U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: Lib.SentencePair -> Lib.Token -> Lib.Token -> a -> a)
                   (w1 :: a)
                   (ww :: Lib.Sentence)
                   (ww1 :: Lib.Sentence) ->
                 let {
                   wild :: Lib.SentencePair = (ww, ww1)
                 } in
                 letrec {
                   go :: [Lib.Token] -> a {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Lib.Token]) ->
                     case ds of wild1 {
                       [] -> w1
                       : y ys
                       -> let {
                            z :: a = go ys
                          } in
                          letrec {
                            go1 :: [Lib.Token] -> a {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Lib.Token]) ->
                              case ds1 of wild2 { [] -> z : y1 ys1 -> w wild y y1 (go1 ys1) }
                          } in
                          go1 ww }
                 } in
                 go ww1) -}
f07ba5a2d9ff3f31c7e249b725887115
  $wgo ::
    [([Lib.Token], [Lib.Token])]
    -> (# Data.Set.Base.Set Lib.Token, Data.Set.Base.Set Lib.Token #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
1162e09e792efe05890e388e94d2287c
  $wgo1 ::
    [([Lib.Token], [Lib.Token])]
    -> (# Data.Set.Base.Set Lib.Token, Data.Set.Base.Set Lib.Token #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
b92976d304350e9999e30898ef5de813
  $wgo2 ::
    [Lib.Probs -> Lib.Probs] -> GHC.Prim.Int# -> Lib.Probs -> Lib.Probs
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*U><L,U>,
     Inline: [0] -}
47cd4b195a284f728fec1a7301ac6afd
  $witerations ::
    GHC.Prim.Int# -> Lib.Corpus -> Lib.Probs -> Lib.Probs
  {- Arity: 2, Strictness: <S,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#) (w :: Lib.Corpus) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<# 0# ww) of wild {
                   GHC.Types.False -> GHC.Base.id @ Lib.Probs
                   GHC.Types.True
                   -> let {
                        w1 :: [Lib.Probs -> Lib.Probs]
                        = case Lib.$wloop w of ww1 { (#,#) ww2 ww3 ->
                          GHC.Types.: @ (Lib.Probs -> Lib.Probs) ww2 ww3 }
                      } in
                      \ (w2 :: Lib.Probs) -> Lib.$wgo2 w1 ww w2 }) -}
891557e37ff59774779b817d06a3cc3b
  $wloop ::
    Lib.Corpus
    -> (# Lib.Probs -> Lib.Probs, [Lib.Probs -> Lib.Probs] #)
  {- Arity: 1, Strictness: <L,U>, Inline: [0] -}
79e78e942e68cd49c511ac0744070ca6
  $wperplexity :: Lib.Corpus -> Lib.Probs -> GHC.Prim.Float#
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ (w :: Lib.Corpus) (w1 :: Lib.Probs) ->
                 letrec {
                   $wgo6 :: [[GHC.Types.Char]]
                            -> [[GHC.Types.Char]] -> GHC.Prim.Float#
                     {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0] -}
                   = \ (w2 :: [[GHC.Types.Char]]) (w3 :: [[GHC.Types.Char]]) ->
                     case w2 of wild {
                       [] -> 1.0#
                       : ipv ipv1
                       -> case w3 of wild1 {
                            [] -> 1.0#
                            : ipv2 ipv3
                            -> case $wgo6 ipv1 ipv3 of ww { DEFAULT ->
                               case Data.HashMap.Base.lookup
                                      @ ([GHC.Types.Char], [GHC.Types.Char])
                                      @ GHC.Types.Float
                                      Lib.$s!_$s$fEq(,)
                                      Lib.$s!_$s$fHashable(,)
                                      (ipv2, ipv)
                                      w1 of wild2 {
                                 GHC.Base.Nothing -> case Lib.$s!1 ret_ty GHC.Prim.Float# of {}
                                 GHC.Base.Just v1
                                 -> case v1 of wild3 { GHC.Types.F# y ->
                                    GHC.Prim.timesFloat# ww y } } } } }
                 } in
                 letrec {
                   $wgo7 :: [([Lib.Token], [Lib.Token])] -> GHC.Prim.Float#
                     {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
                   = \ (w2 :: [([Lib.Token], [Lib.Token])]) ->
                     case w2 of wild {
                       [] -> 0.0#
                       : y ys
                       -> case $wgo7 ys of ww { DEFAULT ->
                          case y of wild1 { (,) f e ->
                          case $wgo6 f e of ww1 { DEFAULT ->
                          case GHC.Prim.logFloat# ww1 of wild2 { DEFAULT ->
                          case GHC.Prim.logFloat# 2.0# of wild3 { DEFAULT ->
                          case GHC.Prim.divideFloat# wild2 wild3 of wild4 { DEFAULT ->
                          GHC.Prim.minusFloat# ww wild4 } } } } } } }
                 } in
                 $wgo7 w) -}
6222d17ab31b8b74e7038fdc384cc8b5
  $wpoly_go1 ::
    GHC.Prim.Word#
    -> [GHC.Types.Char]
    -> GHC.Prim.Int#
    -> Data.HashMap.Base.HashMap [GHC.Types.Char] v
    -> GHC.Base.Maybe v
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><S,1*U><L,U><S,1*U>,
     Inline: [0] -}
d990eff46a4fd02ec61dce4a331ae81c
  $wpoly_go2 ::
    [GHC.Types.Char]
    -> GHC.Prim.Array# (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Base.Maybe v
  {- Arity: 4, HasNoCafRefs, Strictness: <S,1*U><S,U><S,U><S,U>,
     Inline: [0] -}
b6f3f8da62d015358799da1bf84e3f21
  type Corpus = [Lib.SentencePair]
a3301fd6c33c6e4781bf7ffbd58c5f9d
  type Counts =
    Data.HashMap.Base.HashMap (Lib.Token, Lib.Token) GHC.Types.Float
3d09e4cd5dec93b953e3d02eb89e7aa9
  type Dictionary = Data.Set.Base.Set Lib.Token
3a5c97cfaae5c399c0d7cd3adc568432
  type Probs =
    Data.HashMap.Base.HashMap (Lib.Token, Lib.Token) GHC.Types.Float
3006f8cb6dc3c19341720eab4ee7ea67
  type Sentence = [Lib.Token]
9e731c18f684b51223e6968c6c1a1eb0
  type SentencePair = (Lib.Sentence, Lib.Sentence)
adec4015774dc9a8b84f32a1c34321f0
  type Token = GHC.Base.String
6cb0c69467f6225599e63d0098b308b8
  type Totals = Data.HashMap.Base.HashMap Lib.Token GHC.Types.Float
94173f8fb667c88df1b0fae8efbe167c
  extractDict :: Lib.Corpus -> (Lib.Dictionary, Lib.Dictionary)
  {- Arity: 1, Strictness: <S,1*U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Corpus) ->
                 case Lib.$wgo w of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
9ac531f4561d6d35fd4ef2309d56b8f4
  foldPair ::
    (Lib.SentencePair -> Lib.Token -> Lib.Token -> a -> a)
    -> a -> Lib.SentencePair -> a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,C(C1(C1(C1(U))))><L,U><S(LS),1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: Lib.SentencePair -> Lib.Token -> Lib.Token -> a -> a)
                   (w1 :: a)
                   (w2 :: Lib.SentencePair) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 Lib.$wfoldPair @ a w w1 ww1 ww2 }) -}
4e0a8c77744974678c7476ddd9b33f2e
  initProbs :: Lib.Corpus -> Lib.Probs
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (corpus :: Lib.Corpus) ->
                 let {
                   probs :: GHC.Types.Float
                   = case Lib.$wgo1 corpus of ww { (#,#) ww1 ww2 ->
                     case ww2 of wild {
                       Data.Set.Base.Bin dt ds1 ds2 ds3
                       -> case GHC.Prim.divideFloat#
                                 1.0#
                                 (GHC.Prim.int2Float# dt) of wild2 { DEFAULT ->
                          GHC.Types.F# wild2 }
                       Data.Set.Base.Tip
                       -> case GHC.Prim.divideFloat# 1.0# 0.0# of wild2 { DEFAULT ->
                          GHC.Types.F# wild2 } } }
                 } in
                 letrec {
                   go :: [Lib.SentencePair]
                         -> Data.HashMap.Base.HashMap (Lib.Token, Lib.Token) GHC.Types.Float
                         -> Data.HashMap.Base.HashMap (Lib.Token, Lib.Token) GHC.Types.Float
                     {- Arity: 2, Strictness: <S,1*U><S,U> -}
                   = \ (ds :: [Lib.SentencePair])
                       (eta :: Data.HashMap.Base.HashMap
                                 (Lib.Token, Lib.Token) GHC.Types.Float) ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> case y of wild1 { (,) f e ->
                          letrec {
                            go1 :: [Lib.Token]
                                   -> Data.HashMap.Base.HashMap
                                        (Lib.Token, Lib.Token) GHC.Types.Float
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [Lib.Token]) ->
                              case ds1 of wild2 {
                                [] -> eta
                                : y1 ys1
                                -> let {
                                     z :: Data.HashMap.Base.HashMap
                                            (Lib.Token, Lib.Token) GHC.Types.Float
                                     = go1 ys1
                                   } in
                                   letrec {
                                     go2 :: [Lib.Token]
                                            -> Data.HashMap.Base.HashMap
                                                 (Lib.Token, Lib.Token) GHC.Types.Float
                                       {- Arity: 1, Strictness: <S,1*U> -}
                                     = \ (ds2 :: [Lib.Token]) ->
                                       case ds2 of wild3 {
                                         [] -> z
                                         : y2 ys2
                                         -> case probs of v2 { GHC.Types.F# ipv ->
                                            Data.HashMap.Base.insert
                                              @ (Lib.Token, Lib.Token)
                                              @ GHC.Types.Float
                                              Lib.$s!_$s$fEq(,)
                                              Lib.$s!_$s$fHashable(,)
                                              (y1, y2)
                                              v2
                                              (go2 ys2) } }
                                   } in
                                   go2 f }
                          } in
                          go ys (go1 e) } }
                 } in
                 go
                   corpus
                   (Data.HashMap.Base.Empty
                      @ (Lib.Token, Lib.Token)
                      @ GHC.Types.Float)) -}
aab6b0d0a8581eddaf5e3462ad6e3af6
  iterations :: GHC.Types.Int -> Lib.Corpus -> Lib.Probs -> Lib.Probs
  {- Arity: 2, Strictness: <S(S),1*U(U)><L,U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lib.Corpus) ->
                 case w of ww { GHC.Types.I# ww1 -> Lib.$witerations ww1 w1 }) -}
3f63d7d7f9f5601fe76eb8b72cde2e2a
  loop :: Lib.Corpus -> [Lib.Probs -> Lib.Probs]
  {- Arity: 1, Strictness: <L,U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lib.Corpus) ->
                 case Lib.$wloop w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ (Lib.Probs -> Lib.Probs) ww1 ww2 }) -}
bfcf4b5c1d0ba08d4f2313c657e192a2
  perplexity :: Lib.Corpus -> Lib.Probs -> GHC.Types.Float
  {- Arity: 2, Strictness: <S,1*U><L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Lib.Corpus) (w1 :: Lib.Probs) ->
                 case Lib.$wperplexity w w1 of ww { DEFAULT -> GHC.Types.F# ww }) -}
cd13938f31f34fbeb528213a8a5e43e9
  readCorpus ::
    GHC.Base.String -> GHC.Base.String -> GHC.Types.IO Lib.Corpus
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: InlineRule (0, True, True)
                Lib.readCorpus1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (GHC.Types.N:IO[0] <Lib.Corpus>_R)) -}
39a3d7695995db149af352a23361976e
  readCorpus1 ::
    GHC.Base.String
    -> GHC.Base.String
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Lib.Corpus #)
  {- Arity: 3, Strictness: <L,U><L,U><S,U>,
     Unfolding: (\ (filef :: GHC.Base.String)
                   (filee :: GHC.Base.String)
                   (eta :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.IO.Handle.FD.openFile1
                        filef
                        GHC.IO.IOMode.ReadMode
                        eta of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv1
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 case GHC.IO.Handle.FD.openFile1
                        filee
                        GHC.IO.IOMode.ReadMode
                        ipv2 of ds3 { (#,#) ipv4 ipv5 ->
                 case GHC.IO.Handle.Text.hGetContents1
                        ipv5
                        ipv4 of ds4 { (#,#) ipv6 ipv7 ->
                 (# ipv6,
                    Lib.readCorpus_go
                      (Data.OldList.lines ipv3)
                      (Data.OldList.lines ipv7) #) } } } }) -}
d744064e0f22814679ae0f39a59079de
  readCorpus_go ::
    [[GHC.Types.Char]]
    -> [[GHC.Types.Char]] -> [([[GHC.Types.Char]], [GHC.Base.String])]
  {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
a502600ff086a5d114f39a57618ae002
  showProbs :: Lib.Probs -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (eta1 :: Data.HashMap.Base.HashMap
                              (GHC.Base.String, GHC.Base.String) GHC.Types.Float) ->
                 Lib.showProbs_go1 (GHC.Types.[] @ GHC.Types.Char) eta1) -}
0ba10696301adfe57fd727d32e8e0335
  showProbs_go1 ::
    [GHC.Types.Char]
    -> Data.HashMap.Base.HashMap
         (GHC.Base.String, GHC.Base.String) GHC.Types.Float
    -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <L,1*U><S,1*U> -}
39ad907df83f7ea70499209879b49dc8
  step :: Lib.Corpus -> Lib.Probs -> Lib.Probs
  {- Arity: 2, Strictness: <L,1*U><S,U> -}
d4e15870b51b77a808cd94b925ffdbfe
  testCorpus :: Lib.Corpus
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.SentencePair
                   Lib.testCorpus17
                   Lib.testCorpus1) -}
73e80aeeb18705778a249762765cf982
  testCorpus1 :: [Lib.SentencePair]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.SentencePair
                   Lib.testCorpus12
                   Lib.testCorpus2) -}
b309ce8b229890e39acb9f635a5e465f
  testCorpus10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Buch"#) -}
303d89b5b76b65d9e1de78e66cac80d5
  testCorpus11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ein"#) -}
c62ed0785847576e787d9e590b20c8b4
  testCorpus12 :: ([Lib.Token], [Lib.Token])
  {- Strictness: m,
     Unfolding: ((Lib.testCorpus15, Lib.testCorpus13)) -}
fb72d5973f6509fd166bd796e685ddfb
  testCorpus13 :: [Lib.Token]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.Token
                   Lib.testCorpus14
                   Lib.testCorpus5) -}
f4c418cf094931d68647b05a0bac099b
  testCorpus14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "the"#) -}
aaf1d68a99c4eaa9a5bac2b2f64223b6
  testCorpus15 :: [Lib.Token]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.Token
                   Lib.testCorpus16
                   Lib.testCorpus9) -}
e9ce8a7f24a107e6d46df0509787eaa2
  testCorpus16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "das"#) -}
c7261a3129ac1cff851bfe09a159bdec
  testCorpus17 :: ([Lib.Token], [Lib.Token])
  {- Strictness: m,
     Unfolding: ((Lib.testCorpus21, Lib.testCorpus18)) -}
55aabb3683a319674bd0f27fe5a2e5b2
  testCorpus18 :: [Lib.Token]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.Token
                   Lib.testCorpus14
                   Lib.testCorpus19) -}
048be6c91f3db76753c75ed1e420be29
  testCorpus19 :: [Lib.Token]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.Token
                   Lib.testCorpus20
                   (GHC.Types.[] @ Lib.Token)) -}
c2e7dbf260a242516b165266fbde79bd
  testCorpus2 :: [Lib.SentencePair]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.SentencePair
                   Lib.testCorpus3
                   (GHC.Types.[] @ Lib.SentencePair)) -}
506ede3f1af5751f65ba744da2456c64
  testCorpus20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "House"#) -}
a2722eb5a201c6d5a1cae2b9c8e7ce02
  testCorpus21 :: [Lib.Token]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.Token
                   Lib.testCorpus16
                   Lib.testCorpus22) -}
93e164911066d49be7af330cd28cbd07
  testCorpus22 :: [Lib.Token]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.Token
                   Lib.testCorpus23
                   (GHC.Types.[] @ Lib.Token)) -}
4f038172e3fdc92b072d0e4dd5115878
  testCorpus23 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Haus"#) -}
c2311aa3914cfbd8f977fcf26b9987a6
  testCorpus3 :: ([Lib.Token], [Lib.Token])
  {- Strictness: m,
     Unfolding: ((Lib.testCorpus8, Lib.testCorpus4)) -}
d53e2909c38882f6b97e12acd8917146
  testCorpus4 :: [Lib.Token]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.Token
                   Lib.testCorpus7
                   Lib.testCorpus5) -}
817892cb3b6cd97de35d48c5bd1ff634
  testCorpus5 :: [Lib.Token]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.Token
                   Lib.testCorpus6
                   (GHC.Types.[] @ Lib.Token)) -}
79b15b0e97df33fdd1df35394d73536d
  testCorpus6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "book"#) -}
fe139cc4106c24aebe5bbcacce8967fb
  testCorpus7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "a"#) -}
ef5a204f87df190fb99dfa20e823e6e2
  testCorpus8 :: [Lib.Token]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.Token
                   Lib.testCorpus11
                   Lib.testCorpus9) -}
921d49aa6f7a4ac5ceef9da5f28a164c
  testCorpus9 :: [Lib.Token]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Lib.Token
                   Lib.testCorpus10
                   (GHC.Types.[] @ Lib.Token)) -}
"SPEC/Lib $fEq(,) @ Token @ Token" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                              Lib.Token)
                                                   ($dEq1 :: GHC.Classes.Eq Lib.Token)
  GHC.Classes.$fEq(,) @ [GHC.Types.Char]
                      @ [GHC.Types.Char]
                      $dEq
                      $dEq1
  = Lib.$s!_$s$fEq(,)
"SPEC/Lib $fHashable(,) @ Token @ Token" [ALWAYS] forall ($dHashable :: Data.Hashable.Class.Hashable
                                                                          Lib.Token)
                                                         ($dHashable1 :: Data.Hashable.Class.Hashable
                                                                           Lib.Token)
  Data.Hashable.Class.$fHashable(,) @ [GHC.Types.Char]
                                    @ [GHC.Types.Char]
                                    $dHashable
                                    $dHashable1
  = Lib.$s!_$s$fHashable(,)
"SPEC/Lib $fHashable(,)_$chash @ Token @ Token" [ALWAYS] forall ($dHashable :: Data.Hashable.Class.Hashable
                                                                                 Lib.Token)
                                                                ($dHashable1 :: Data.Hashable.Class.Hashable
                                                                                  Lib.Token)
  Data.Hashable.Class.$fHashable(,)_$chash @ [GHC.Types.Char]
                                           @ [GHC.Types.Char]
                                           $dHashable
                                           $dHashable1
  = Lib.$s!_$s$fHashable(,)_$chash
"SPEC/Lib $fHashable(,)_$chashWithSalt @ Token @ Token" [ALWAYS] forall ($dHashable :: Data.Hashable.Class.Hashable
                                                                                         Lib.Token)
                                                                        ($dHashable1 :: Data.Hashable.Class.Hashable
                                                                                          Lib.Token)
  Data.Hashable.Class.$fHashable(,)_$chashWithSalt @ [GHC.Types.Char]
                                                   @ [GHC.Types.Char]
                                                   $dHashable
                                                   $dHashable1
  = Lib.$s!_$s$fHashable(,)_$chashWithSalt
"SPEC/Lib $wupdateOrSnocWithKey @ [Char] _" [0] forall @ v
                                                       (w :: GHC.Classes.Eq [GHC.Types.Char])
  Data.HashMap.Strict.$wupdateOrSnocWithKey @ [GHC.Types.Char] @ v w
  = Lib.$s$wupdateOrSnocWithKey @ v
"SPEC/Lib insertWith @ [Char] _" [ALWAYS] forall @ v
                                                 ($dEq :: GHC.Classes.Eq [GHC.Types.Char])
                                                 ($dHashable :: Data.Hashable.Class.Hashable
                                                                  [GHC.Types.Char])
  Data.HashMap.Strict.insertWith @ [GHC.Types.Char]
                                 @ v
                                 $dEq
                                 $dHashable
  = Lib.$sinsertWith @ v
"SPEC/Lib lookup @ [Char] _" [ALWAYS] forall @ v
                                             ($dEq :: GHC.Classes.Eq [GHC.Types.Char])
                                             ($dHashable :: Data.Hashable.Class.Hashable
                                                              [GHC.Types.Char])
  Data.HashMap.Base.lookup @ [GHC.Types.Char] @ v $dEq $dHashable
  = Lib.$s!_$slookup @ v
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

